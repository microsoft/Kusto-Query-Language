// <#+
#if !T4
namespace Kusto.Language.Generator
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
#endif

    /// <summary>
    /// A utility class for writing the text of other programs.
    /// </summary>
    /// <remarks>This class does not take a dependency on anything not in the BCL.</remarks>
    internal class CodeGenerator
    {
        #region Private data
        private StringWriter m_swriter;
        private IndentedTextWriter m_writer;
        private bool m_emptyAbove;
        #endregion

        #region Construction
        public CodeGenerator()
        {
            m_swriter = new StringWriter();
            m_writer = new IndentedTextWriter(m_swriter, "    ");
            m_emptyAbove = true;
        }
        #endregion

        #region Public API
        /// <summary>
        /// Gets the full program text written thus far.
        /// </summary>
        public string GetText()
        {
            return m_swriter.ToString();
        }

        public void WriteHeader(string templateExtension, string templateName)
        {
            WriteLine(@"
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------
// <autogenerated>
//   This file was generated automatically from a {0} file that included
//   the {1} file.
//   Do not modify this file by hand -- modify the original {0} file.
//   Do not check-in this file!
// </autogenerated>

// Disable pragma warnings for auto-generated code
#pragma warning disable 472,429 
", templateExtension, templateName);
        }

        /// <summary>
        /// Add a block of "using namespace X".
        /// </summary>
        /// <param name="usingNamespaces">The custom namespaces to "use" in the block.</param>
        /// <param name="addBclNamespaces">Whether to add a few useful BCL namespace.</param>
        /// <param name="addKcpNamespaces">Whether to add a few useful Kusto.Cloud.Platform namespaces.</param>
        public void WriteUsingBlock(IEnumerable<string> usingNamespaces, bool addBclNamespaces, bool addKcpNamespaces)
        {
            var bclCommonNamespaces = new[]
            {
                "System",
                "System.Collections.Generic",
                "System.Globalization",
                "System.Runtime.Serialization",
            };

            var kcpNamespaces = new List<string>
            {
                "Kusto.Cloud.Platform.Utils"
            };

            var nsCommon = new List<string>();
            var nsDotNetOnly = new List<string>();

            if (addBclNamespaces)
            {
                foreach (var namspace in bclCommonNamespaces)
                {
                    if (!nsCommon.Contains(namspace))
                    {
                        nsCommon.Add(namspace);
                    }
                }
              
            }
            if (addKcpNamespaces)
            {
                foreach (var namspace in kcpNamespaces)
                {
                    if (!nsCommon.Contains(namspace))
                    {
                        nsCommon.Add(namspace);
                    }
                }
            }
            if (usingNamespaces != null)
            {
                foreach (var namspace in usingNamespaces)
                {
                    if (!nsCommon.Contains(namspace))
                    {
                        nsCommon.Add(namspace);
                    }
                }
            }

            foreach (string n in nsCommon)
            {
                WriteLine("using {0};", n);
            }
        }

        /// <summary>
        /// Writes a namespace declaration and inside it runs a continuation action.
        /// The namespace declaration is closed automatically once the action returns.
        /// </summary>
        /// <param name="namespace">The namespace to create.</param>
        /// <param name="inside">The action to run inside the namespace.</param>
        public void WriteNamespaceDeclaration(string @namespace, Action inside)
        {
            WriteNamespaceDeclarationBegin(@namespace);
            inside();
            WriteNamespaceDeclarationEnd();
        }

        /// <summary>
        /// Writes the beginning part of a namespace declaration.
        /// </summary>
        public void WriteNamespaceDeclarationBegin(string @namespace)
        {
            WriteLine();
            WriteLine("namespace {0}", @namespace);
            WriteLine("{");
            m_writer.Indent++;
        }

        /// <summary>
        /// Writes the ending part of a namespace declaration.
        /// </summary>
        public void WriteNamespaceDeclarationEnd()
        {
            m_writer.Indent--;
            WriteLine("}");
        }

        /// <summary>
        /// Writes an "if(@if) { inside(); }" block
        /// </summary>
        public void WriteIfBlock(string @if, Action inside)
        {
            WriteScopeStart($"if ({@if})");
            inside();
            WriteScopeEnd();
        }

        /// <summary>
        /// Writes an "if(@if) { body }" block
        /// </summary>
        public void WriteIfBlock(string @if, string body)
        {
            WriteScopeStart($"if ({@if})");
            WriteLine(body);
            WriteScopeEnd();
        }

        public void WriteRegion(string region, Action inside)
        {
            WriteRegionBegin(region);
            inside();
            WriteRegionEnd(region);
        }

        public void WriteRegionBegin(string region)
        {
            WriteEmptyLineIfNeeded();
            WriteLine("#region {0}", region);
            m_emptyAbove = true;
        }

        public void WriteRegionEnd(string region)
        {
            WriteLine("#endregion /* {0} */", region);
        }

        public void WriteDocString(string summary, string remarks = null)
        {
            if (!string.IsNullOrWhiteSpace(summary))
            {
                WriteLine("/// <summary>");
                WriteLine("/// {0}", summary);
                WriteLine("/// </summary>");
            }

            if (!string.IsNullOrEmpty(remarks))
            {
                WriteLine("/// <remarks>");
                WriteLine("/// {0}", remarks);
                WriteLine("/// </remarks>");
            }
        }

        /// <summary>
        /// Writes a string and a new indented scope, calls the action,
        /// then ends the scope.
        /// </summary>
        /// <param name="head">The string preceding the new scope.</param>
        /// <param name="inside">The action to run inside the scope.</param>
        public void WriteScope(string head, Action inside)
        {
            WriteScopeStart(head);
            inside();
            WriteScopeEnd();
        }

        public void WriteScopeStart()
        {
            WriteLine("{");
            m_writer.Indent++;
        }

        public void WriteScopeStart(string head)
        {
            WriteLine(head);
            WriteLine("{");
            m_writer.Indent++;
        }

        public void WriteScopeEnd()
        {
            m_writer.Indent--;
            WriteLine("}");
        }

        public void UnsafeIndent()
        {
            m_writer.Indent++;
        }

        public void UnsafeUnindent()
        {
            m_writer.Indent--;
        }

        /// <summary>
        /// If the line above the current line is not empty, write a new line.
        /// </summary>
        public void WriteEmptyLineIfNeeded()
        {
            if (!m_emptyAbove)
            {
                WriteLine(null);
            }
        }

        public void WriteLine()
        {
            WriteLine(null);
        }

        private static readonly string[] c_newline = new string[] { System.Environment.NewLine };

        public void WriteLine(string text, bool detectNewLines = true)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                m_emptyAbove = true;
                m_writer.WriteLine();
                return;
            }

            if (detectNewLines && text.Contains(Environment.NewLine))
            {
                var lines = text.Split(c_newline, StringSplitOptions.None);
                foreach (var line in lines)
                {
                    m_writer.WriteLine(line);
                }
            }
            else
            {
                m_writer.WriteLine(text);
            }
            if (text.EndsWith(Environment.NewLine) || text.EndsWith("{"))
            {
                m_emptyAbove = true;
            }
            else
            {
                m_emptyAbove = false;
            }
        }

        public void WriteLine(string format, params object[] args)
        {
            var text = string.Format(format, args);
            WriteLine(text);
        }
        #endregion

        #region Static utility methods
        /// <summary>
        /// Given a compoundName/CompoundName, returns the corresponding PascalCase 
        /// version of the name (CompoundName).
        /// </summary>
        public static string GetPascalCase(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
            var first = Char.ToUpper(name[0]);
            if (name.Length == 1)
            {
                return first.ToString();
            }
            return first + name.Substring(1);
        }

        /// <summary>
        /// Given a compoundName/CompoundName, returns the corresponding CamelCase
        /// version of the name (compoundName).
        /// </summary>
        public static string GetCamelCase(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
            var first = Char.ToLower(name[0]);
            if (name.Length == 1)
            {
                return first.ToString();
            }
            var ret = first + name.Substring(1);
            if (ret == "operator") // Add here all C# keywords people dream up
            {
                return "@" + ret;
            }
            return ret;
        }

        /// <summary>
        /// Given a compoundName/CompoundName, returns the corresponding ClassMemberName
        /// version of the name(m_compoundName).
        /// </summary>
        public static string GetClassMemberName(string name)
        {
            return "m_" + GetCamelCase(name);
        }
        #endregion
    }

    #region class IndentedTextWriter
    /// <summary>
    /// An implementation of <see cref="TextWriter"/> that can indent new lines
    /// by a tbaStringToken
    /// </summary>
    /// <remarks>
    /// This code is copied from .NET's source code, as a temporary measure
    /// to help porting to .NET Core 2.x.
    /// </remarks>
    internal class IndentedTextWriter : TextWriter
    {
        private TextWriter writer;
        private int indentLevel;
        private bool tabsPending;
        private string tabString;

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string DefaultTabString = "    ";

        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.IndentedTextWriter'/> using the specified
        ///       text writer and default tab string.
        ///    </para>
        /// </devdoc>
        public IndentedTextWriter(TextWriter writer) : this(writer, DefaultTabString)
        {
        }

        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.IndentedTextWriter'/> using the specified
        ///       text writer and tab string.
        ///    </para>
        /// </devdoc>
        public IndentedTextWriter(TextWriter writer, string tabString) : base(CultureInfo.InvariantCulture)
        {
            this.writer = writer;
            this.tabString = tabString;
            indentLevel = 0;
            tabsPending = false;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Encoding Encoding
        {
            get
            {
                return writer.Encoding;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets or sets the new line character to use.
        ///    </para>
        /// </devdoc>
        public override string NewLine
        {
            get
            {
                return writer.NewLine;
            }

            set
            {
                writer.NewLine = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of spaces to indent.
        ///    </para>
        /// </devdoc>
        public int Indent
        {
            get
            {
                return indentLevel;
            }
            set
            {
                Debug.Assert(value >= 0, "Bogus Indent... probably caused by mismatched Indent++ and Indent--");
                if (value < 0)
                {
                    value = 0;
                }
                indentLevel = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets or sets the TextWriter to use.
        ///    </para>
        /// </devdoc>
        public TextWriter InnerWriter
        {
            get
            {
                return writer;
            }
        }

        internal string TabString
        {
            get { return tabString; }
        }

        /// <devdoc>
        ///    <para>
        ///       Closes the document being written to.
        ///    </para>
        /// </devdoc>
        public override void Close()
        {
            writer.Close();
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Flush()
        {
            writer.Flush();
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OutputTabs()
        {
            if (tabsPending)
            {
                for (int i = 0; i < indentLevel; i++)
                {
                    writer.Write(tabString);
                }
                tabsPending = false;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Writes a string
        ///       to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(string s)
        {
            OutputTabs();
            writer.Write(s);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Boolean value to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(bool value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes a character to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes a
        ///       character array to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char[] buffer)
        {
            OutputTabs();
            writer.Write(buffer);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes a subarray
        ///       of characters to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char[] buffer, int index, int count)
        {
            OutputTabs();
            writer.Write(buffer, index, count);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Double to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(double value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of
        ///       a Single to the text
        ///       stream.
        ///    </para>
        /// </devdoc>
        public override void Write(float value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an integer to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(int value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an 8-byte integer to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(long value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an object
        ///       to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(object value)
        {
            OutputTabs();
            writer.Write(value);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string, using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, object arg0)
        {
            OutputTabs();
            writer.Write(format, arg0);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string,
        ///       using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, object arg0, object arg1)
        {
            OutputTabs();
            writer.Write(format, arg0, arg1);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string,
        ///       using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, params object[] arg)
        {
            OutputTabs();
            writer.Write(format, arg);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the specified
        ///       string to a line without tabs.
        ///    </para>
        /// </devdoc>
        public void WriteLineNoTabs(string s)
        {
            writer.WriteLine(s);
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the specified string followed by
        ///       a line terminator to the text stream.
        ///    </para>
        /// </devdoc>
        public override void WriteLine(string s)
        {
            OutputTabs();
            writer.WriteLine(s);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>
        ///       Writes a line terminator.
        ///    </para>
        /// </devdoc>
        public override void WriteLine()
        {
            OutputTabs();
            writer.WriteLine();
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Boolean followed by a line terminator to
        ///       the text stream.
        ///    </para>
        /// </devdoc>
        public override void WriteLine(bool value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char[] buffer)
        {
            OutputTabs();
            writer.WriteLine(buffer);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char[] buffer, int index, int count)
        {
            OutputTabs();
            writer.WriteLine(buffer, index, count);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(double value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(float value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(int value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(long value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(object value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, object arg0)
        {
            OutputTabs();
            writer.WriteLine(format, arg0);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, object arg0, object arg1)
        {
            OutputTabs();
            writer.WriteLine(format, arg0, arg1);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, params object[] arg)
        {
            OutputTabs();
            writer.WriteLine(format, arg);
            tabsPending = true;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        // [CLSCompliant(false)]
        public override void WriteLine(UInt32 value)
        {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        internal void InternalOutputTabs()
        {
            for (int i = 0; i < indentLevel; i++)
            {
                writer.Write(tabString);
            }
        }
    }

    internal class Indentation
    {
        private IndentedTextWriter writer;
        private int indent;
        private string s;

        internal Indentation(IndentedTextWriter writer, int indent)
        {
            this.writer = writer;
            this.indent = indent;
            s = null;
        }

        internal string IndentationString
        {
            get
            {
                if (s == null)
                {
                    string tabString = writer.TabString;
                    StringBuilder sb = new StringBuilder(indent * tabString.Length);
                    for (int i = 0; i < indent; i++)
                    {
                        sb.Append(tabString);
                    }
                    s = sb.ToString();
                }
                return s;
            }
        }
    }
    #endregion

#if !T4
}
#endif 
// #>
